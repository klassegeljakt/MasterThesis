\clearpage

# Implementation

The implementation is in pure Scala with one dependency to the Shapeless library. Usage of macros is sparse.

## Shallow Embedded DSL

The shallow embedded DSL is a runtime and compile time string interpolator, as shown in [@lst:sc]. The interpolators are implemented as extension methods and extension macros for the `StringContext` class respectively. Both take a option which indicates how the spliced string should be statically checked. Four options are available: `"item"`, `"expr"`, `"type"`, and `"file"`. The first three tell the interpolator to verify that the string is a grammatically sound item, expression, or type, by piping it through Rust's `syn` parser. In contrast, `"file"` saves the snippet to a temporary file on disk and compiles it with `rustc`.

```{#lst:sc .scala caption="Rust string interpolators."}
implicit class RustInterpolator(val sc: StringContext) {
  def rrust(args: String*)(option: String): String = rustrImpl(sc, opt, args)
  def crust(args: String*)(option: String): String = macro rustcImpl
}
```

[@Lst:rrust] contains the runtime interpolator method. The call to `getSnippet` splices the string parts with the arguments into a snippet. Next, `checkSnippet` passes the snippet to `rustc` or `syn` in a separate process, depending on the option. If the process reports an error, i.e., the error code is not zero, a runtime exception is thrown with the snippet and error message, otherwise the snippet is returned.

```{#lst:rrust .scala caption="Runtime string interpolator method."}
def rustrImpl(sc: StringContext, option: String, args: Seq[String]): String = {
  val snippet = getSnippet(sc.parts, args)
  val (errorCode, errorMsg) = checkSnippet(snippet, option)
  if(errorCode != 0) {
    throw new RustException(s"$errorMsg\n>> $snippet <<\n")
  }
  snippet
}
```

[@Lst:crust] defines the compile time interpolator macro. The logic is at large the same as the runtime interpolator, with a difference being how the parameters need to be excavated from the AST. For example, `option` is extracted from `expOption.tree` through `Literal(Constant(option: String))`. As a requirement, all `expArgs` must be string literals. If `rustc` or `syn` reports an error, the macro will abort compilation with an error message.

```{#lst:crust .scala caption="Compile time string interpolator macro."}
def rustcImpl(c: Context)(expArgs: c.Expr[String]*)
                         (expOption: c.Expr[String]): c.Expr[String] = {
  import c.universe._
  val args = expArgs.map(expArg => getSplice(c)(expArg))
  val parts = getParts(c)
  val Literal(Constant(option: String)) = expOption.tree
  val snippet = getSnippet(parts, args)
  val (errorCode, errorMsg) = checkSnippet(snippet, option)
  if(errorCode != 0) {
    c.abort(c.enclosingPosition, s"$errorMsg\n>> $snippet <<\n")
  }
  c.Expr[String](Literal(Constant(snippet)))
}
```

## Deeply Embedded DSL

The construct and interpretation categories for the deeply embedded DSL are illustrated in [@lst:toplvl]. Constructs are required to implement the `show`{.Scala} method from the `Showable`{.Scala} trait. The `show` method generates code by directly printing it to a file with a designated `PrintWriter`{.Scala}. `ShowName`{.Scala} and `Show`{.Scala} are type classes for showing types. Place expressions are distinct in how they can both be evaluated and assigned to. Only a subset of items can be declared in traits. For example, a trait may contain a method but not a struct. `Items` which can appear in traits are `TraitItem`s. Expressions, let- and item declarations can all occur in statement position. 

```{#lst:toplvl .scala caption="Interpretations and constructs."}
// Interpretations
trait Showable { def show(pw: PrintWriter): Unit }
trait ShowName[T] extends Showable // Type class
trait Show[T]     extends Showable // Type class
// Constructs
trait Node        extends Showable // AST Node
trait Pat         extends Node     // Pattern
trait Stm         extends Node     // Statement
trait Exp[T]      extends Stm      // Expression
trait PlaceExp[T] extends Exp[T]   // Place Expression
trait Item        extends Stm      // Item Declaration
trait TraitItem   extends Item     // Trait Item Declaration
```

Constructs are implemented as SAM instances wherever possible. As an example, the root of the AST is a `File`{.Scala} node ([@lst:file]) taking a variable number of item declarations. Code for `File`{.Scala} is generated by invoking `show`{.Scala} on its item declarations. For convenience, an implicit class with a method `sep`{.Scala} is implemented for showing delimited sequences of `Showable` objects.

```{#lst:file .scala caption="File implementation."}
def File(items: Item*): Node = pw => items.sep("\n").show(pw)
```

### Types

The DSL represents proper types directly as Scala types, e.g., `i32`{.Scala} in [@lst:types]. Polymorphic types are depicted as Scala types with one HList type parameter, e.g., `HashMap[i32::bool::HNil]`{.Scala}. The `HList`{.Scala} contains the generics and lifetime parameters of the type. References are represented as `ref[L,T]`{.Scala} where `L`{.Scala} is a lifetime and `T`{.Scala} is a type. Tuples, arrays, and slices are not yet supported.

```{#lst:types .scala caption="Types"}
trait i32; trait bool; trait HashMap[T]; trait static; trait ref[L,T]
// Example
type A = i32                      // i32
type B = HashMap[i32::bool::HNil] // HashMap<i32,bool>
type C = ref[static,i32]          // &'static i32
```

Type and lifetime annotations are a prerequisite for item declarations. Given an AST node parameterized by a type `T`, it must be possible to show `T`. The DSL uses a type class `Show[T]`{.Scala} to show a type `T`{.Scala}. By default, implicit resolution for a type `Show[HashMap[i32::bool::HNil]]`{.Scala} will produce `"HashMap<i32,bool>"`{.Scala}. A second type class `ShowName[T]`{.Scala} exists for only showing the name of a type, e.g., `ShowName[HashMap[i32::bool::HNil]]]`{.Scala} outputs `"HashMap"`{.Scala}. In [@lst:impl4], the type class instance `showName`{.Scala} extracts a type's name from a `ClassTag`{.Scala} and prints it. The `showProper`{.Scala} and `showPoly`{.Scala} instances show proper types and polymorphic types respectively. There is no ambiguity between the two as the latter has a more specific return type.

```{#lst:impl4 .scala caption="Type class instances for showing types."}
implicit def showName[T](implicit ev: ClassTag[T]): ShowName[T] =
  pw => pw.print(ev.toString.split("(\\.|\\$)").last)

implicit def showProper[T](implicit ev: ShowName[T]): Show[T] =
  pw => ev.show(pw)

implicit def showPoly[A[_], B <: HList, C <: HList]
(implicit ev0: ShowName[A[_]],
          ev1: LiftAll.Aux[Show, B, C],
          ev2: ToTraversable.Aux[C, List, Show[_]]
): Show[A[B]] =
  pw => show"$ev0<${ev1.instances.toList[Show[_]].sep(",")}>"(pw)

// Example
implicitly[Show[HashMap[i32::bool::HNil]]].show(pw) // HashMap<i32,bool>
```

A type `Show[HashMap[i32::bool::HNil]]`{.Scala} will resolve to `showPolyType`{.Scala} which in effect requests evidence for `ShowName[HashMap[_]]`{.Scala} to extract the name `"HashMap"`{.Scala}. Afterwards, Shapeless' `LiftAll`{.Scala} retrieves the `Show`{.Scala} type class instance for each element in `i32::bool::HNil`{.Scala}. Finally, Shapeless' `ToList`{.Scala} transforms the result of `LiftAll`{.Scala} into a `List[Show[_]]`{.Scala}. A string interpolator `show`{.Scala} is implemented for showing a string, spliced with object of type `Showable`{.Scala}. For example, `show"<$x>"(pw)`{.Scala} will execute `{pw.print("<"); x.show(pw); pw.print(">")}`{.Scala}. Furthermore, an implicit conversion from `String` to `Showable` exists, allowing `Strings` to be spliced as well.

It is possible to override what a type generates to by defining a custom type class instance of `ShowName`{.Scala} for it, as displayed in [@lst:override]. For example, Rust's unit type `()` can be expressed by overriding `unit`.

```{#lst:override .scala caption="Overriding types."}
trait unit
implicit val showunit:    ShowName[unit]       = () => "()"
implicit val showHashMap: ShowName[HashMap[_]] = () => "BinaryTree"
// Example
implicitly[Show[HashMap[i32::unit::HNil]]].show(pw) // BinaryTree<i32,()>
```

### Literals

Every expression is parameterized by an invariant type parameter, indicating what the expression evaluates to. One class of expression are literals, defined in [@lst:lit]. The value a literal evaluates to is stored as a string.

```{#lst:lit .scala caption="Add"}
case class Lit[T](value: String): Exp[T] = pw => pw.print(value)
// Example
val i = Lit[i32]("1")
val b = Lit[bool]("true")
i.show(pw) // 1
b.show(pw) // true
```

### Unary Operators

Rust has the unary and binary operators highlighted in [@tbl:ops]. Scala is able to overload the unary prefix operators '`+`', '`-`', '`!`' and '`~`' [@ScalaSpec, (ch. 6.12.1)]. Other unary prefix operators can be programmed as regular methods, and as a result require parentheses at the use-site.

| Category          | Symbols                             |
|-------------------+-------------------------------------|
| Unary             | `-  !  &  *                       ` |
| Binary-Arithmetic | `+  -  *  /  %  +=  -=  *=  /=  %=` |
| Binary-Relational | `<  >  <=  >=  ==  !=             ` |
| Binary-Logical    | `&&  ||                           ` |
| Binary-Bitwise    | `^  &  |  <<  >>  ^=  &=  <<=  >>=` |
| Other             | `;  =  _  :  .  ..  ...  @  ?     ` |

: Rust's operators [@RustOperators]. {#tbl:ops}

[@Lst:unary] defines the unary prefix operators '`&`', '`*`' and '`!`', i.e., reference-of, dereference, and logic negation. The '`*`' and '`&`' operators are regular methods which correspondingly unwrap and wrap a `ref[L,T]` around a type. When dereferencing, the result is a place expression. The '`!`' operator is overloaded for boolean expressions with an extension method `unary_!`.

```{#lst:unary .scala caption="Unary operators."}
def &[T](v: Exp[T]): Exp[ref[static,T]] = pw => show"(&$v)"(pw)
def *[T](v: Exp[ref[_,T]]): PlaceExp[T] = pw => show"(*$v)"(pw)
implicit class Logical(v: Exp[bool]) {
  def unary_!: Exp[bool]                = pw => show"(!$v)"(pw)
}
// Example
val val1 = *(&(i))
val val2 = !b // Desugars to b.unary_!
val1.show(pw) // *(&(1)))
val2.show(pw) // !true
```

### Binary Operators

Binary operators are programmed as extension methods as well. [@Lst:binary] defines '`+`', '`:=`' and '`#:`', equivalent to '`+`', '`=`' and '`;`'. The '`=:`' operator assigns a value to a place expression, requiring both operands to be of the same type. The '`#:`' operator terminates a statement followed by an expression. Both '`=:`' and '`#:`' end with '`:`' and are in consequence right-associative. Right-associativity for '`#:`' implicates `{a #: b #: c;}` is evaluated as `{a;{b;{c;}}}` instead of `{{{a};b}c;}`. All assignment operators are right-associative, e.g., `x = y = z` is evaluated as `x = (y = z)`. Certain operators, such as relational operators, require parentheses, e.g., `(x == y) == z`. The remaining operators are left-associative.

```{#lst:binary .scala caption="Binary operators for addition, assignment, and statement termination."}
implicit class Add[T](val l: Exp[T]) {
  def +(r: Exp[T]): Exp[T]     = pw => show"($l + $r)"(pw)
}
implicit class Assign[T](val r: PlaceExp[T]) {
  def =:(l: Exp[T]): Exp[unit] = pw => show"$l = $r"(pw)
}
implicit class Terminate[T](val r: Exp[T]) {
  def #:(l: Stm): Exp[T]       = pw => show"$l; $r"(pw)
}
// Example
val exps = (val1 =: (i+i)) #: b
exps.show(pw) // (*(&1)) = (1+1); true
```

### If-Else

[@Lst:cflow] defines the `If` expression which requires a condition and if-clause. `If` can be chained with `Else` into an if-else, given that the if- and else-clause evaluate to values of the same type. Because `If` has more than one method, it cannot be written as a SAM instance.

```{#lst:cflow .Scala caption="If-Else definition."}
def If[T](cond: Exp[bool])(ic: Exp[T]) = new Exp[T] {
  def Else(ec: Exp[T]): Exp[T] = pw => show"if $cond { $ic } else { $ec }"(pw)
  def show(pw: PrintWriter) =          show"if $cond { $ic }"(pw)
}
// Example
val if_else = If(b) { i+i } Else { i }
if_else.show(pw) // if true { 1+1 } else { 1 }
```

### Let

A variable is treated by the DSL as a function with one argument. For example, `{let x: i32 = 3; x+x}` is isomorphic to `(|x: i32| x+x )(3)`. The `Let` node in [@lst:var], for generating a `let` declaration, takes a `value`, an `id`, and a function `fn`. The `id` is by default generated with `new_id` which is a global counter, but can also be specified manually. The `value` is bound to a `variable` with name `id`. `Let` evaluates to the `result` of applying `fn` to the `variable`.

```{#lst:var .Scala caption="Let definition."}
def Let[T,O](value: Exp[T], id: String = new_id)
            (fn: PlaceExp[T] => Exp[O]): Exp[O] =
 pw => {
    val variable: PlaceExp[T] = pw => pw.print(id)
    val result = fn(variable)
    show"{let $variable = $rhs; $result}"(pw)
 }
// Example
val let1 = Let(i) { x => x+x }
let1.show(pw) // {let x1 = 1; (x1 + x1)}
val let2 = Let(i, "x") { x => x+x }
let2.show(pw) // {let x = 1; (x + x)}
```

### Functions

Functions, and other items, are implemented with fluent interfaces. The idea is to construct the function incrementally through method chaining, adding arguments, bounds, attributes, etc. When finished, the function can either be declared, called or inlined. The parameters of the fluent interface are declared in [@lst:fnheader]. A function must have a name, but the rest, i.e., attributes, bounds, arguments, and body, is optional. Arguments are stored in both a Shapeless `HList`{.Scala} and a regular `List`{.Scala}. The purpose of the `HList`{.Scala} is to abstract over the arity of the input argument list, and ensure type safety inside the function body. The `List`{.Scala} is solely used for showing the arguments. The `FnArg` type can either be instantiated as an ordinary argument or a self-argument. By default, the return type of a function is the unit type `()`{.Rust} unless specified otherwise, e.g., `fn main() { ... }`{.Rust} desugars to `fn main() -> () { ... }`{.Rust}. Hence, `O`{.Scala}, which is the return type, is by default inferred to `unit`{.Scala}, using the `Default`{.Scala} type class described in the background.

```{#lst:fnheader .Scala caption="Fluent interface parameters (Function)"}
case class Fn[I <: HList, O:Df[unit]#L](
  NAME:    String              = "",
  ATTRS:   String              = "",
  BOUNDS:  String              = "",
  ARGS:    I                   = HNil,
  ARGLIST: List[FnArg[_]]      = List(),
  BODY:    Option[I => Exp[O]] = None
) extends Exp[O] {
```

[@Lst:arg] describes the implementation for ordinary arguments. An argument may either appear declared in a function signature, inserted at a call-site, used in a function body, or inlined as a local variable. Arguments must therefore be able to show their identifier, expression, and type. The identifier is given using Shapeless' `Witness.Aux[K]` which extracts the value from a singleton type literal.

```{#lst:arg .Scala caption="Argument definition."}
def newArg[K,V](exp: Exp[V])
               (implicit ev1: Witness.Aux[K], ev2: Show[V]) = new FnArg[V] {
  val id = ev1.value.toString
  def decl:   Stm = pw =>     show"$id: $ev2"(pw)
  def inline: Stm = pw =>     show"let $id = $exp"(pw)
  def insert: Stm = pw =>     show"$exp"(pw)
  def show(pw: PrintWriter) = show"$id"(pw)
}
```

Each parameter in the interface comes with setter method. For instance, `arg` in [@lst:fnstage] is a method part of the fluent interface for adding an argument to the function. As input, `arg` expects an record field where the value is an expression, e.g., `("id" ->> exp)`. A corresponding field is then created and added to the fluent interface. `K` and `V` require view bounds for propagating the implicits the `newArg` method expects.

```{#lst:fnstage .Scala caption="Staging a function."}
def arg[K:Witness.Aux, V:Show](exp: FieldType[K, Exp[V]]) = {
  val arg = field[K](newArg[K,V](exp))
  Fn(NAME, ATTRS, BOUNDS, arg::ARGS, arg::ARGLIST, None)
}
```

[@Lst:fnunstage] displays how the fluent interface declares a method. Since Rust demands explicit type annotations in the function signature, implicit evidence is needed for declaring the output type. Conditionally, the function body is only declared if it has been specified.

```{#lst:fnunstage .Scala caption="Unstaging a function."}
def decl(implicit ev: Show[O]): TraitItem = pw => {
  val input = ARGLIST.reverse.map(_.decl).sep(", ")
  if (BODY.isEmpty) {
    show"fn $NAME$BOUNDS($input) -> $ev;"(pw)
  } else {
    val output = BODY.get.apply(ARGS)
    show"fn $NAME$BOUNDS($input) -> $ev {$output}"(pw)
  }
}
```

The fluent interface can then be used as in listing [@lst:fntest] for writing a function which calculates the maximum value of two integers. `PH`, or PlaceHolder, is an object which can which can be implicitly converted into any other expression. In other words, `PH` can always be passed in place of an expression, and can be used as a placeholder for expressions when creating item declarations.

```{#lst:fntest .Scala caption="Function example"}
def max(x: Exp[i32], y: Exp[i32]) =
  Fn()
    .name("max")
    .arg("x" ->> x)
    .arg("y" ->> y)
    .returns[i32]
    .body { args =>
      If(args("x") > args("y")) { args("x") } Else { args("y") }
    }

max(i, i+i).show(pw)        // max(1, 1+1)
max(i, i+i).inline.show(pw) // if (1 > 1+1) { 1 } else { 1+1 } 
max(PH, PH).decl.show(pw)
// fn max(x: i32, y: i32) -> i32 {if (x > y) { x } else { y }}

```

## Structs

The fluent interface for structs employ the same strategy as functions. A struct has a type, and optionally fields, bounds, and attributes. These are defined in [@lst:struct]. `S` is the type of the struct, and `F` is the types of the fields. The struct's type is thereby separated from its fields, as is specified for nominal types.

```{#lst:struct .Scala caption="Fluent interface parameters (Struct)"}
case class Struct[S, F <: HList](
  NAME:      Showable          = "",
  BOUNDS:    String            = "",
  ATTRS:     String            = "",
  FIELDLIST: List[StructField] = List()
) extends Exp[S] { ... }
```

[@Lst:accessfield] implements the '`f`' operator, equivalent to '`.`', for accessing fields. When invoking '`f`' on an expression `Exp[S]`, the compiler will attempt to find implicit evidence for `Struct[S,F]`, which if found unifies `F`. As input, the '`f`' operator takes a key and uses Shapeless' `Selector.Aux[F,key.T,V]` to unify the type `V` of its associated value. The product is a place expression of type `V`, representing the accessed field.

```{#lst:accessfield .scala caption="Access field"}
implicit class FieldAccess[S,F<:HList](exp: Exp[S])
                                      (implicit ev: Struct[S,F]) {
  def f[V](key: Witness)
          (implicit ev: Selector.Aux[F,key.T,V]): PlaceExp[V] =
    pw => show"$exp.${key.value.toString}"(pw)
}
```

As an example, listing [@lst:structtest] displays how to declare a `Point` struct with two integer fields. The implicit value is required as evidence for looking up the fields.

```{#lst:structtest .scala caption="Struct example"}
trait Point
val point(x: Exp[i32], y: Exp[i32]) =
  Struct()
    .name[Point]
    .field("x" ->> x)
    .field("y" ->> y)
implicit val pointDefinition = point(PH,PH)

point(PH, PH).decl.show(pw) // struct Point { x: i32, y: i32 }
Let(point(i, i)) { s =>
  s.f("y")
}.show(pw) // let x1 = Point { x: 1, y: 1 }; x1.y
```

<!--## Traits and Impl-->

<!--Traits and implementations are equivalent to type classes and type class instances. Given a trait `T` and a type `S`, it should be possible to query for an implementation of `T` for `S`. Traits contain trait items which are either constant values, methods, type aliases, or macros [@SynTraitItem]. At the moment, only methods are supported. [@Lst:math] illustrates how to declare a Rust trait, the user first declares a regular type class `Math[Self]` containing instances of `Fn`. Then, an instance of the type class is passed to a fluent interface, which declares all the members.-->

<!--```{#lst:trait .scala caption="Trait example"}-->
<!--// Trait-->
<!--trait Math[S] {-->
  <!--def square(a: Exp[S]) =-->
    <!--Fn()-->
      <!--.arg("a" ->> a)-->
      <!--.returns[i32]-->
      <!--.body { args =>-->
        <!--args("a") * args("a")-->
      <!--}-->
<!--}-->
<!--val math =-->
  <!--Trait().-->
    <!--.inst(new Math[Self])-->
    <!--.member(_.square.decl)-->
<!--```-->

<!--The trait is subsequently implemented by instantiating the type class as shown in [@lst:impl]. -->

<!--```{#lst:impl .scala caption="Impl example"}-->
<!--// Implementation-->
<!--implicit def Mathi32 = new Math[i32] {}-->
<!--val mathi32 =-->
  <!--Impl().-->
    <!--.inst(i32Math)-->
    <!--.self[i32]-->
    <!--.member(_.square.decl)-->

<!--math.decl.show(pw)-->
<!--mathi32.decl.show(pw)-->
<!--```-->
