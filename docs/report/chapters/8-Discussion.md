\clearpage

# Discussion

The evaluation for the shallow DSL is as expected. The runtime interpolator, with calls to *rustc*, passes all the tests, but is also the most limited as it only accepts whole files as input. When instead using *syn*, the interpolators fail to detect type errors. Moreover, the *syn* parser gives little advantage over using IntelliJ's language injection, since language injection will in addition to parsing also do linting and name binding. A different approach would be to generate a Rust parser which parses a Rust AST, and analyze it semantically through macros. At present time, the official grammar at the Rust repository is not canonical and might therefore not work as expected.

The compile time interpolators return an AST string literal, but it appears the AST is not propagated to other macro calls. The solution libraries such as Quill employ, for communicating between macros, is to encode AST information inside of types [@Quill]. The idea is to move information from the AST into the symbol table, which is accessible by all macros. In Quill, everything is a whitebox macro which produces an AST with an associated type annotation. The type annotation encodes information about the AST. Other macros can then access the AST by decoding the type annotation.

The deeply embedded DSL is currently limited in the number of constructs it can express, but should have more potential than the shallow DSL. One potential is to turn the AST into an UAST by adding interpretations to other languages, e.g., C or C++. The DSL might even be able to introduce new semantics to the languages. For instance, C's lack of generics could be compensated for by generating monomorphic code. A generic struct in Rust such as `struct Point<T> { x: T, y: T }` could be expressed in C by generating duplicates, e.g., `Point_int { int x; int y; }` and `Point_float { float x; float y; }`, covering the needs for all use-sites. Unifying Rust with C++ is more difficult since their concepts do not map well to each other.

Support for coercions is one of the main missing semantic features. Implicit conversions could be one way of implementing coercions. A different approach is to turn expressions covariant, i.e., `Exp[+T]` instead of `Exp[T]`. Scala's lower-upper-bounding inference can make covariance problematic. If `Exp` is covariant, then the result of adding two expressions of unrelated types, e.g., `Exp[i32]` and `Exp[f32]`, will produce `Exp[Any]`. By default, Scala will not complain over inferring `Any`, but this could be solved by adding the flags: `-Ywarn-infer-any` and `-Xfatal-warnings`. 

Another missing feature are patterns, which is a pre-requisite for constructs such as `Enum`s and `match`. While implicits could be used to verify if a pattern matches an expression, the difficult part is extracting the matching variables from the pattern. An idea is to express all patterns using Rust's '`@`' operator. The '`@`' operator binds the match of a pattern to a single variable. For example, given a `struct Foo { x: i32, y: i32 }`, the pattern `Foo { x, y } => x+y` would be expressed as `foo @ Foo { _, _ } => foo.x+foo.y`. This should be easier to work with since only one variable needs to be taken into consideration.

Structural types, i.e., tuples, arrays, and slices, require backing as well. Tuples could be expressed as regular `HList`s. Arrays are more difficult since their size is part of the type, e.g., the type of an array with five integers is `[i32, 5]`. Creating a unique type for each size, such as `_1`, `_2`, ..., is one solution. Another is to express the size as a singleton type literal. When Scala's establishes first-class language support for these, it should be possible to express arrays as `array[i32,5]`.

Nothing currently prevents an immutable place expression from being mutated. Mutability is not tracked, but could be by embedding additional type information into expressions. A mutable expression could be expressed as `Mutable extends Exp[T]`, and an immutable as `Exp[T]`. Thereby, any mutable expression can be converted to immutable, but not the other way around.

## Design goals

The shallow embedded DSL covers all of Rust's syntax and semantics. In addition, the DSL can be extended with new items which may also be monkey-patched at runtime. A downside is how static checking is restricted to string literals which are whole compilation units. However, the benefit of string literals is the consistency between the written and generated code, since everything is generated exactly as written. Combined with linting from language injection, it should also be easy for the user to detect syntax errors and name clashes.

The deeply embedded DSL is held back by the host language, and as a result cannot cover all of Rust's semantics. Macros could although possibly be used to change Scala's semantics into something which accommodates for Rust's. Despite semantics are only verified up until type checking, this might be enough for most tasks. In terms of ease-of-use, the combination of ADTs and fluent interfaces makes the code relatively easy to read and write, but it is not always obvious what will be generated.

